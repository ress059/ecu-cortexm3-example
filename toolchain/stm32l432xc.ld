/**
 * @file
 * @brief Linker script for STM32L432 microcontroller. This was adapted from
 * the linker script auto-generated by STM32CubeIDE and is meant to be used
 * as an initial starting point. This script currently does the simplest
 * configuration which is booting from FLASH (address 0x08000000) and only
 * using SRAM1 block.
 *
 * @author Ian Ress
 * @version 0.1
 * @date 2024-08-03
 * @copyright Copyright (c) 2024
 */



/* Stack sizes must be aligned on an 8-byte boundary. */
main_stack_size_ = 2000;
process_stack_size_ = 0; /* For simplicity the process and main stack will be shared. */
heap_size_ = 0;


OUTPUT_FORMAT("elf32-littlearm", "elf32-bigarm", "elf32-littlearm")
ENTRY(reset_isr_handler)


MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 256K
    SRAM1 (rwx) : ORIGIN = 0x20000000, LENGTH = 64K
    SRAM2 (rwx) : ORIGIN = 0x10000000, LENGTH = 16K
}


SECTIONS
{
    .isr_vector : ALIGN(4)
    {
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH

    .text : ALIGN(4)
    {
        *(.text)
        *(.text*)
        *(.glue_7)          /* glue arm to thumb code. */
        *(.glue_7t)         /* glue thumb to arm code. */
        *(.eh_frame)        /* For C++ exceptions. Just leaving in for now. */
        *(.init)            /* We write our own startup code but still include these for now. */
        *(.fini)            /* We write our own startup code but still include these for now. */
        . = ALIGN(4);
    } >FLASH

    .rodata : ALIGN(4)
    {
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
    } >FLASH
    
    /* For C++ exceptions. Just leaving in for now. */
    .ARM.extab : ALIGN(4)
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } >FLASH
    
    .ARM : ALIGN(4)
    {
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } >FLASH

    /* Array of function pointers called before main(). */
    .preinit_array : ALIGN(4)
    {
        __preinit_array_start = .;
        KEEP(*(.preinit_array*))
        __preinit_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    /* Array of function pointers called before main(). Usually for C++ static/global constructors. */
    .init_array : ALIGN(4)
    {
        __init_array_start = .;
        KEEP(*(SORT(.init_array.*)))
        KEEP (*(.init_array*))
        __init_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    /* Array of function pointers called if main() exits. Usually for C++ static/global destructors. */
    .fini_array : ALIGN(4)
    {
        __fini_array_start = .;
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array*))
        __fini_array_end = .;
        . = ALIGN(4);
    } >FLASH

    /* .data in FLASH stores values for initialized global and static variables. Symbols 
    declared here indicate the start and end of .data so we can copy it over from FLASH 
    into RAM on startup. */
    . = ALIGN(4);
    data_start_flash_ = LOADADDR(.data);
    .data :
    {
        data_start_ram_ = .;
        *(.data)
        *(.data*)
        . = ALIGN(4);
        data_end_ram_ = .;
    } >SRAM1 AT> FLASH
    
    /* .bss stores uninitialized global and static variables. Symbols declared here 
    indicate the start and end of .bss so we can 0 it out on startup. */
    .bss (NOLOAD) : ALIGN(4)
    {
        bss_start_ = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        bss_end_ = .;
    } >SRAM1

    .heap (NOLOAD) : ALIGN(4)
    {
        heap_start_ = .;
        . = . + heap_size_;
        heap_end_ = .;
        . = ALIGN(8);
    } >SRAM1

    main_stack_start_ = ORIGIN(SRAM1) + LENGTH(SRAM1);
    .stack (NOLOAD) : ALIGN(8)
    {
        process_stack_end_ = .;
        . = . + process_stack_size_;
        . = ALIGN(8);
        process_stack_start_ = .;
        main_stack_end_ = .;
        . = . + main_stack_size_;
        . = ALIGN(8);
        /* Use any remaining SRAM for the main stack. We explicitly write out the allocation for main stack
        size so the linker can give us an error if the specified main_stack_size_ is too large. */
    } >SRAM1

    .ARM.attributes 0 : 
    { 
        *(.ARM.attributes) 
    }
}
