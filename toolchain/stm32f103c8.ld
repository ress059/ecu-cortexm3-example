/**
 * @file stm32f103c8.ld
 * @brief Linker script for STM32F103C8 microcontroller. This was adapted from
 * the linker script auto-generated by STM32CubeIDE with the following edits:
 *
 * 1. glue_7 and glue_7t input sections were removed from .text section. These sections are 
 *    responsible for converting between ARM and thumb instructions. Since ARM Cortex M3 only 
 *    supports thumb instruction set this is not needed.
 *
 * 2. .eh_frame input section was removed from .text section. This section is used for C++ 
 *    exceptions. Since exceptions are removed if this toolchain file is used (-fno-exceptions
 *    passed to compiler) this is not needed.
 *
 * 3. Set heap size to 0 since it is not used.
 *
 * Other notes:
 * 1. .ARM.extab and .ARM sections contain information for unwinding the stack if any 
 *    such functions you use may need this. So it should be kept in.
 *
 * @author Ian Ress
 * @version 0.1
 * @date 2024-08-03
 * @copyright Copyright (c) 2024
 */


/* Sizes must be aligned on 8-byte boundary */
stack_size_ = 1000;
heap_size_ = 0;

ENTRY(reset_isr_handler)

MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
    SRAM (rwx) : ORIGIN = 0x20000000, LENGTH = 20K
}

SECTIONS
{
    .isr_vector :
    {
        . = ALIGN(4);
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH

    .text :
    {
        . = ALIGN(4);
        *(.text)
        *(.text*)
        KEEP(*(.init))
        KEEP(*(.fini))
        . = ALIGN(4);
    } >FLASH

    .rodata :
    {
        . = ALIGN(4);
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
    } >FLASH
    
    .ARM.extab : 
    {
        . = ALIGN(4);
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } >FLASH
    
    .ARM : 
    {
        . = ALIGN(4);
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .preinit_array :
    {
        . = ALIGN(4);
        __preinit_array_start = .;
        KEEP(*(.preinit_array*))
        __preinit_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .init_array :
    {
        . = ALIGN(4);
        __init_array_start = .;
        KEEP(*(SORT(.init_array.*)))
        KEEP (*(.init_array*))
        __init_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .fini_array :
    {
        . = ALIGN(4);
        __fini_array_start = .;
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array*))
        __fini_array_end = .;
        . = ALIGN(4);
    } >FLASH

    /* .data in FLASH stores values for initialized global and static variables. Symbols 
    declared here indicate the start and end of .data so we can copy it over from FLASH 
    into RAM on startup. */
    data_start_flash_ = LOADADDR(.data);
    .data :
    {
        . = ALIGN(4);
        data_start_ram_ = .;
        *(.data)
        *(.data*)
        *(.RamFunc)
        *(.RamFunc*)
        . = ALIGN(4);
        data_end_ram_ = .;
    } >SRAM AT> FLASH
    
    /* .bss stores uninitialized global and static variables. Symbols declared here 
    indicate the start and end of .bss so we can 0 it out on startup. */
    . = ALIGN(4);
    .bss :
    {
        bss_start_ = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        bss_end_ = .;
    } >SRAM

    /* Used so linker script throws error if there is not enough RAM left to satisfy 
    user's stack and heap size requirements. */
    ._user_heap_stack :
    {
        . = ALIGN(8);
        . = . + heap_size_;
        . = . + stack_size_;
        . = ALIGN(8);
    } >SRAM

    /* Remove information from the compiler libraries */
    /DISCARD/ :
    {
        libc.a ( * )
        libm.a ( * )
        libgcc.a ( * )
    }

    .ARM.attributes 0 : 
    { 
        *(.ARM.attributes) 
    }
}

/* Stack grows from top-down on ARM Cortex M3 */
stack_start_ = ORIGIN(RAM) + LENGTH(RAM);