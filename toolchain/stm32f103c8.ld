/**
 * @file stm32f103c8.ld
 * @brief Linker script for STM32F103C8 microcontroller. This was adapted from
 * the linker script auto-generated by STM32CubeIDE with the following edits:
 *
 * 1. glue_7 and glue_7t input sections were removed from .text section. These sections are 
 *    responsible for converting between ARM and thumb instructions. Since ARM Cortex M3 only 
 *    supports thumb instruction set this is not needed.
 *
 * 2. .eh_frame input section was removed from .text section. This section is used for C++ 
 *    exceptions. Since exceptions are removed if this toolchain file is used (-fno-exceptions
 *    passed to compiler) this is not needed.
 *
 * 3. Removed redundant padding in beginning of all sections since location counter is already
 *    aligned at the end of each section.
 *
 * 4. Remove heap since it is not used.
 *
 * Other notes:
 * 1. .ARM.extab and .ARM sections contain information for unwinding the stack if any 
 *    such functions you use may need this. So it should be kept in.
 *
 * @author Ian Ress
 * @version 0.1
 * @date 2024-08-03
 * @copyright Copyright (c) 2024
 */


ENTRY(reset_handler)

/* Highest address of the user mode stack */
/* TODO MAY DELETE THIS */
_estack = ORIGIN(RAM) + LENGTH(RAM); /* end of "RAM" Ram type memory */
_Min_Heap_Size = 0x200 ; /* required amount of heap */
_Min_Stack_Size = 0x400 ; /* required amount of stack */

end of stack = RAM end

MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
    SRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 20K
}


SECTIONS
{
    .isr_vector :
    {
        KEEP(*(.isr_vector))
        . = ALIGN(4);
    } >FLASH

    .text :
    {
        *(.text)
        *(.text*)
        KEEP(*(.init))
        KEEP(*(.fini))
        . = ALIGN(4);
    } >FLASH
    
    .rodata :
    {
        *(.rodata)
        *(.rodata*)
        . = ALIGN(4);
    } >FLASH
    
    .ARM.extab : 
    {
        *(.ARM.extab* .gnu.linkonce.armextab.*)
        . = ALIGN(4);
    } >FLASH
    
    .ARM : 
    {
        __exidx_start = .;
        *(.ARM.exidx*)
        __exidx_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .preinit_array :
    {
        __preinit_array_start = .;
        KEEP(*(.preinit_array*))
        __preinit_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .init_array :
    {
        __init_array_start = .;
        KEEP(*(SORT(.init_array.*)))
        KEEP (*(.init_array*))
        __init_array_end = .;
        . = ALIGN(4);
    } >FLASH
    
    .fini_array :
    {
        __fini_array_start = .;
        KEEP(*(SORT(.fini_array.*)))
        KEEP(*(.fini_array*))
        __fini_array_end = .;
        . = ALIGN(4);
    } >FLASH

    /* .data in FLASH stores values for initialized global and static variables. Symbols 
    declared here indicate the start and end of .data so we can copy it over from FLASH 
    into RAM on startup. */
    data_start_flash_ = LOADADDR(.data);
    .data :
    {
        data_start_ram_ = .;
        *(.data)
        *(.data*)
        *(.RamFunc)
        *(.RamFunc*)
        . = ALIGN(4);
        data_end_ram_ = .;
    } >SRAM AT> FLASH
    
    /* .bss stores uninitialized global and static variables. Symbols declared here 
    indicate the start and end of .bss so we can 0 it out on startup. */
    .bss :
    {
        bss_start_= .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        . = ALIGN(4);
        bss_end_ = .;
    } >SRAM

  /* User_heap_stack section, used to check that there is enough "RAM" Ram  type memory left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >RAM

  /* Remove information from the compiler libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
}
